/*!
* jQuery Form Plugin
* version: 2.92 (22-NOV-2011)
* @requires jQuery v1.3.2 or later
*
* Examples and documentation at: http://malsup.com/jquery/form/
* Dual licensed under the MIT and GPL licenses:
*http://www.opensource.org/licenses/mit-license.php
*http://www.gnu.org/licenses/gpl.html
*/
;(function($) {
/*
Usage Note:
-----------
Do not use both ajaxSubmit and ajaxForm on the same form.  These
functions are intended to be exclusive.  Use ajaxSubmit if you want
to bind your own submit handler to the form.  For example,
$(document).ready(function() {
$('#myForm').bind('submit', function(e) {
e.preventDefault(); // <-- important
$(this).ajaxSubmit({
target: '#output'
});
});
});
Use ajaxForm when you want the plugin to manage all the event binding
for you.  For example,
$(document).ready(function() {
$('#myForm').ajaxForm({
target: '#output'
});
});
When using ajaxForm, the ajaxSubmit function will be invoked for you
at the appropriate time.
*/
/**
* ajaxSubmit() provides a mechanism for immediately submitting
* an HTML form using AJAX.
*/
$.fn.ajaxSubmit = function(options) {
// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
if (!this.length) {
log('ajaxSubmit: skipping submit process - no element selected');
return this;
}
var method, action, url, $form = this;
if (typeof options == 'function') {
options = { success: options };
}
method = this.attr('method');
action = this.attr('action');
url = (typeof action === 'string') ? $.trim(action) : '';
url = url || window.location.href || '';
if (url) {
// clean url (don't include hash vaue)
url = (url.match(/^([^#]+)/)||[])[1];
}
options = $.extend(true, {
url:  url,
success: $.ajaxSettings.success,
type: method || 'GET',
iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
}, options);
// hook for manipulating the form data before it is extracted;
// convenient for use with rich editors like tinyMCE or FCKEditor
var veto = {};
this.trigger('form-pre-serialize', [this, options, veto]);
if (veto.veto) {
log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
return this;
}
// provide opportunity to alter form data before it is serialized
if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
log('ajaxSubmit: submit aborted via beforeSerialize callback');
return this;
}
var traditional = options.traditional;
if ( traditional === undefined ) {
traditional = $.ajaxSettings.traditional;
}
var qx,n,v,a = this.formToArray(options.semantic);
if (options.data) {
options.extraData = options.data;
qx = $.param(options.data, traditional);
}
// give pre-submit callback an opportunity to abort the submit
if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
log('ajaxSubmit: submit aborted via beforeSubmit callback');
return this;
}
// fire vetoable 'validate' event
this.trigger('form-submit-validate', [a, this, options, veto]);
if (veto.veto) {
log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
return this;
}
var q = $.param(a, traditional);
if (qx) {
q = ( q ? (q + '&' + qx) : qx );
}
if (options.type.toUpperCase() == 'GET') {
options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
options.data = null;  // data is null for 'get'
}
else {
options.data = q; // data is the query string for 'post'
}
var callbacks = [];
if (options.resetForm) {
callbacks.push(function() { $form.resetForm(); });
}
if (options.clearForm) {
callbacks.push(function() { $form.clearForm(options.includeHidden); });
}
// perform a load on the target only if dataType is not provided
if (!options.dataType && options.target) {
var oldSuccess = options.success || function(){};
callbacks.push(function(data) {
var fn = options.replaceTarget ? 'replaceWith' : 'html';
$(options.target)[fn](data).each(oldSuccess, arguments);
});
}
else if (options.success) {
callbacks.push(options.success);
}
options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
var context = options.context || options;// jQuery 1.4+ supports scope context 
for (var i=0, max=callbacks.length; i < max; i++) {
callbacks[i].apply(context, [data, status, xhr || $form, $form]);
}
};
// are there files to upload?
var fileInputs = $('input:file:enabled[value]', this); // [value] (issue #113)
var hasFileInputs = fileInputs.length > 0;
var mp = 'multipart/form-data';
var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);
var fileAPI = !!(hasFileInputs && fileInputs.get(0).files && window.FormData);
log("fileAPI :" + fileAPI);
var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;
// options.iframe allows user to force iframe mode
// 06-NOV-09: now defaulting to iframe mode if file input is detected
if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
// hack to fix Safari hang (thanks to Tim Molendijk for this)
// see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
if (options.closeKeepAlive) {
$.get(options.closeKeepAlive, function() {
fileUploadIframe(a);
});
}
else {
fileUploadIframe(a);
}
}
else if ((hasFileInputs || multipart) && fileAPI) {
options.progress = options.progress || $.noop;
fileUploadXhr(a);
}
else {
$.ajax(options);
}
// fire 'notify' event
this.trigger('form-submit-notify', [this, options]);
return this;
// XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
function fileUploadXhr(a) {
var formdata = new FormData();
for (var i=0; i < a.length; i++) {
if (a[i].type == 'file')
continue;
formdata.append(a[i].name, a[i].value);
}
$form.find('input:file:enabled').each(function(){
var name = $(this).attr('name'), files = this.files;
if (name) {
for (var i=0; i < files.length; i++)
formdata.append(name, files[i]);
}
});
options.data = null;
var _beforeSend = options.beforeSend;
options.beforeSend = function(xhr, options) {
options.data = formdata;
if (xhr.upload) { // unfortunately, jQuery doesn't expose this prop (http://bugs.jquery.com/ticket/10190)
xhr.upload.onprogress = function(event) {
options.progress(event.position, event.total);
}
}
if (_beforeSend)
_beforeSend.call(options, xhr, options);
}
$.ajax(options);
}
// private function for handling file uploads (hat tip to YAHOO!)
function fileUploadIframe(a) {
var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
var useProp = !!$.fn.prop;
if (a) {
if ( useProp ) {
// ensure that every serialized input is still enabled
for (i=0; i < a.length; i++) {
el = $(form[a[i].name]);
el.prop('disabled', false);
}
} else {
for (i=0; i < a.length; i++) {
el = $(form[a[i].name]);
el.removeAttr('disabled');
}
};
}
if ($(':input[name=submit],:input[id=submit]', form).length) {
// if there is an input with a name or id of 'submit' then we won't be
// able to invoke the submit fn on the form (at least not x-browser)
alert('Error: Form elements must not have name or id of "submit".');
return;
}
s = $.extend(true, {}, $.ajaxSettings, options);
s.context = s.context || s;
id = 'jqFormIO' + (new Date().getTime());
if (s.iframeTarget) {
$io = $(s.iframeTarget);
n = $io.attr('name');
if (n == null)
$io.attr('name', id);
else
id = n;
}
else {
$io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
}
io = $io[0];
xhr = { // mock object
aborted: 0,
responseText: null,
responseXML: null,
status: 0,
statusText: 'n/a',
getAllResponseHeaders: function() {},
getResponseHeader: function() {},
setRequestHeader: function() {},
abort: function(status) {
var e = (status === 'timeout' ? 'timeout' : 'aborted');
log('aborting upload... ' + e);
this.aborted = 1;
$io.attr('src', s.iframeSrc); // abort op in progress
xhr.error = e;
s.error && s.error.call(s.context, xhr, e, status);
g && $.event.trigger("ajaxError", [xhr, s, e]);
s.complete && s.complete.call(s.context, xhr, e);
}
};
g = s.global;
// trigger ajax global events so that activity/block indicators work like normal
if (g && ! $.active++) {
$.event.trigger("ajaxStart");
}
if (g) {
$.event.trigger("ajaxSend", [xhr, s]);
}
if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
if (s.global) {
$.active--;
}
return;
}
if (xhr.aborted) {
return;
}
// add submitting element to data if we know it
sub = form.clk;
if (sub) {
n = sub.name;
if (n && !sub.disabled) {
s.extraData = s.extraData || {};
s.extraData[n] = sub.value;
if (sub.type == "image") {
s.extraData[n+'.x'] = form.clk_x;
s.extraData[n+'.y'] = form.clk_y;
}
}
}
var CLIENT_TIMEOUT_ABORT = 1;
var SERVER_ABORT = 2;
function getDoc(frame) {
var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
return doc;
}
// Rails CSRF hack (thanks to Yvan BARTHÃ‰LEMY)
var csrf_token = $('meta[name=csrf-token]').attr('content');
var csrf_param = $('meta[name=csrf-param]').attr('content');
if (csrf_param && csrf_token) {
s.extraData = s.extraData || {};
s.extraData[csrf_param] = csrf_token;
}
// take a breath so that pending repaints get some cpu time before the upload starts
function doSubmit() {
// make sure form attrs are set
var t = $form.attr('target'), a = $form.attr('action');
// update form attrs in IE friendly way
form.setAttribute('target',id);
if (!method) {
form.setAttribute('method', 'POST');
}
if (a != s.url) {
form.setAttribute('action', s.url);
}
// ie borks in some cases when setting encoding
if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
$form.attr({
encoding: 'multipart/form-data',
enctype:  'multipart/form-data'
});
}
// support timout
if (s.timeout) {
timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
}
// look for server aborts
function checkState() {
try {
var state = getDoc(io).readyState;
log('state = ' + state);
if (state.toLowerCase() == 'uninitialized')
setTimeout(checkState,50);
}
catch(e) {
log('Server abort: ' , e, ' (', e.name, ')');
cb(SERVER_ABORT);
timeoutHandle && clearTimeout(timeoutHandle);
timeoutHandle = undefined;
}
}
// add "extra" data to form if provided in options
var extraInputs = [];
try {
if (s.extraData) {
for (var n in s.extraData) {
extraInputs.push(
$('<input type="hidden" name="'+n+'">').attr('value',s.extraData[n])
.appendTo(form)[0]);
}
}
if (!s.iframeTarget) {
// add iframe to doc and submit the form
$io.appendTo('body');
io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
}
setTimeout(checkState,15);
form.submit();
}
finally {
// reset attrs and remove "extra" input elements
form.setAttribute('action',a);
if(t) {
form.setAttribute('target', t);
} else {
$form.removeAttr('target');
}
$(extraInputs).remove();
}
}
if (s.forceSync) {
doSubmit();
}
else {
setTimeout(doSubmit, 10); // this lets dom updates render
}
var data, doc, domCheckCount = 50, callbackProcessed;
function cb(e) {
if (xhr.aborted || callbackProcessed) {
return;
}
try {
doc = getDoc(io);
}
catch(ex) {
log('cannot access response document: ', ex);
e = SERVER_ABORT;
}
if (e === CLIENT_TIMEOUT_ABORT && xhr) {
xhr.abort('timeout');
return;
}
else if (e == SERVER_ABORT && xhr) {
xhr.abort('server abort');
return;
}
if (!doc || doc.location.href == s.iframeSrc) {
// response not received yet
if (!timedOut)
return;
}
io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);
var status = 'success', errMsg;
try {
if (timedOut) {
throw 'timeout';
}
var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
log('isXml='+isXml);
if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
if (--domCheckCount) {
// in some browsers (Opera) the iframe DOM is not always traversable when
// the onload callback fires, so we loop a bit to accommodate
log('requeing onLoad callback, DOM not available');
setTimeout(cb, 250);
return;
}
// let this fall through because server response could be an empty document
//log('Could not access iframe DOM after mutiple tries.');
//throw 'DOMException: not available';
}
//log('response detected');
var docRoot = doc.body ? doc.body : doc.documentElement;
xhr.responseText = docRoot ? docRoot.innerHTML : null;
xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
if (isXml)
s.dataType = 'xml';
xhr.getResponseHeader = function(header){
var headers = {'content-type': s.dataType};
return headers[header];
};
// support for XHR 'status' & 'statusText' emulation :
if (docRoot) {
xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
}
var dt = (s.dataType || '').toLowerCase();
var scr = /(json|script|text)/.test(dt);
if (scr || s.textarea) {
// see if user embedded response in textarea
var ta = doc.getElementsByTagName('textarea')[0];
if (ta) {
xhr.responseText = ta.value;
// support for XHR 'status' & 'statusText' emulation :
xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
}
else if (scr) {
// account for browsers injecting pre around json response
var pre = doc.getElementsByTagName('pre')[0];
var b = doc.getElementsByTagName('body')[0];
if (pre) {
xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
}
else if (b) {
xhr.responseText = b.textContent ? b.textContent : b.innerText;
}
}
}
else if (dt == 'xml' && !xhr.responseXML && xhr.responseText != null) {
xhr.responseXML = toXml(xhr.responseText);
}
try {
data = httpData(xhr, dt, s);
}
catch (e) {
status = 'parsererror';
xhr.error = errMsg = (e || status);
}
}
catch (e) {
log('error caught: ',e);
status = 'error';
xhr.error = errMsg = (e || status);
}
if (xhr.aborted) {
log('upload aborted');
status = null;
}
if (xhr.status) { // we've set xhr.status
status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
}
// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
if (status === 'success') {
s.success && s.success.call(s.context, data, 'success', xhr);
g && $.event.trigger("ajaxSuccess", [xhr, s]);
}
else if (status) {
if (errMsg == undefined)
errMsg = xhr.statusText;
s.error && s.error.call(s.context, xhr, status, errMsg);
g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
}
g && $.event.trigger("ajaxComplete", [xhr, s]);
if (g && ! --$.active) {
$.event.trigger("ajaxStop");
}
s.complete && s.complete.call(s.context, xhr, status);
callbackProcessed = true;
if (s.timeout)
clearTimeout(timeoutHandle);
// clean up
setTimeout(function() {
if (!s.iframeTarget)
$io.remove();
xhr.responseXML = null;
}, 100);
}
var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
if (window.ActiveXObject) {
doc = new ActiveXObject('Microsoft.XMLDOM');
doc.async = 'false';
doc.loadXML(s);
}
else {
doc = (new DOMParser()).parseFromString(s, 'text/xml');
}
return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
};
var parseJSON = $.parseJSON || function(s) {
return window['eval']('(' + s + ')');
};
var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4
var ct = xhr.getResponseHeader('content-type') || '',
xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
data = xml ? xhr.responseXML : xhr.responseText;
if (xml && data.documentElement.nodeName === 'parsererror') {
$.error && $.error('parsererror');
}
if (s && s.dataFilter) {
data = s.dataFilter(data, type);
}
if (typeof data === 'string') {
if (type === 'json' || !type && ct.indexOf('json') >= 0) {
data = parseJSON(data);
} else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
$.globalEval(data);
}
}
return data;
};
}
};
/**
* ajaxForm() provides a mechanism for fully automating form submission.
*
* The advantages of using this method instead of ajaxSubmit() are:
*
* 1: This method will include coordinates for <input type="image" /> elements (if the element
*is used to submit the form).
* 2. This method will include the submit element's name/value data (for the element that was
*used to submit the form).
* 3. This method binds the submit() method to the form for you.
*
* The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
* passes the options argument along after properly binding events for submit elements and
* the form itself.
*/
$.fn.ajaxForm = function(options) {
// in jQuery 1.3+ we can fix mistakes with the ready state
if (this.length === 0) {
var o = { s: this.selector, c: this.context };
if (!$.isReady && o.s) {
log('DOM not ready, queuing ajaxForm');
$(function() {
$(o.s,o.c).ajaxForm(options);
});
return this;
}
// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
return this;
}
return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
e.preventDefault();
$(this).ajaxSubmit(options);
}
}).bind('click.form-plugin', function(e) {
var target = e.target;
var $el = $(target);
if (!($el.is(":submit,input:image"))) {
// is this a child element of the submit el?  (ex: a span within a button)
var t = $el.closest(':submit');
if (t.length == 0) {
return;
}
target = t[0];
}
var form = this;
form.clk = target;
if (target.type == 'image') {
if (e.offsetX != undefined) {
form.clk_x = e.offsetX;
form.clk_y = e.offsetY;
} else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
var offset = $el.offset();
form.clk_x = e.pageX - offset.left;
form.clk_y = e.pageY - offset.top;
} else {
form.clk_x = e.pageX - target.offsetLeft;
form.clk_y = e.pageY - target.offsetTop;
}
}
// clear form vars
setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
});
};
// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
return this.unbind('submit.form-plugin click.form-plugin');
};
/**
* formToArray() gathers form element data into an array of objects that can
* be passed to any of the following ajax functions: $.get, $.post, or load.
* Each object in the array has both a 'name' and 'value' property.  An example of
* an array for a simple login form might be:
*
* [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
*
* It is this array that is passed to pre-submit callback functions provided to the
* ajaxSubmit() and ajaxForm() methods.
*/
$.fn.formToArray = function(semantic) {
var a = [];
if (this.length === 0) {
return a;
}
var form = this[0];
var els = semantic ? form.getElementsByTagName('*') : form.elements;
if (!els) {
return a;
}
var i,j,n,v,el,max,jmax;
for(i=0, max=els.length; i < max; i++) {
el = els[i];
n = el.name;
if (!n) {
continue;
}
if (semantic && form.clk && el.type == "image") {
// handle image inputs on the fly when semantic == true
if(!el.disabled && form.clk == el) {
a.push({name: n, value: $(el).val(), type: el.type });
a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
}
continue;
}
v = $.fieldValue(el, true);
if (v && v.constructor == Array) {
for(j=0, jmax=v.length; j < jmax; j++) {
a.push({name: n, value: v[j]});
}
}
else if (v !== null && typeof v != 'undefined') {
a.push({name: n, value: v, type: el.type});
}
}
if (!semantic && form.clk) {
// input type=='image' are not found in elements array! handle it here
var $input = $(form.clk), input = $input[0];
n = input.name;
if (n && !input.disabled && input.type == 'image') {
a.push({name: n, value: $input.val()});
a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
}
}
return a;
};
/**
* Serializes form data into a 'submittable' string. This method will return a string
* in the format: name1=value1&amp;name2=value2
*/
$.fn.formSerialize = function(semantic) {
//hand off to jQuery.param for proper encoding
return $.param(this.formToArray(semantic));
};
/**
* Serializes all field elements in the jQuery object into a query string.
* This method will return a string in the format: name1=value1&amp;name2=value2
*/
$.fn.fieldSerialize = function(successful) {
var a = [];
this.each(function() {
var n = this.name;
if (!n) {
return;
}
var v = $.fieldValue(this, successful);
if (v && v.constructor == Array) {
for (var i=0,max=v.length; i < max; i++) {
a.push({name: n, value: v[i]});
}
}
else if (v !== null && typeof v != 'undefined') {
a.push({name: this.name, value: v});
}
});
//hand off to jQuery.param for proper encoding
return $.param(a);
};
/**
* Returns the value(s) of the element in the matched set.  For example, consider the following form:
*
*  <form><fieldset>
*  <input name="A" type="text" />
*  <input name="A" type="text" />
*  <input name="B" type="checkbox" value="B1" />
*  <input name="B" type="checkbox" value="B2"/>
*  <input name="C" type="radio" value="C1" />
*  <input name="C" type="radio" value="C2" />
*  </fieldset></form>
*
*  var v = $(':text').fieldValue();
*  // if no values are entered into the text inputs
*  v == ['','']
*  // if values entered into the text inputs are 'foo' and 'bar'
*  v == ['foo','bar']
*
*  var v = $(':checkbox').fieldValue();
*  // if neither checkbox is checked
*  v === undefined
*  // if both checkboxes are checked
*  v == ['B1', 'B2']
*
*  var v = $(':radio').fieldValue();
*  // if neither radio is checked
*  v === undefined
*  // if first radio is checked
*  v == ['C1']
*
* The successful argument controls whether or not the field element must be 'successful'
* (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
* The default value of the successful argument is true.  If this value is false the value(s)
* for each element is returned.
*
* Note: This method *always* returns an array.  If no valid value can be determined the
*array will be empty, otherwise it will contain one or more values.
*/
$.fn.fieldValue = function(successful) {
for (var val=[], i=0, max=this.length; i < max; i++) {
var el = this[i];
var v = $.fieldValue(el, successful);
if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
continue;
}
v.constructor == Array ? $.merge(val, v) : val.push(v);
}
return val;
};
/**
* Returns the value of the field element.
*/
$.fieldValue = function(el, successful) {
var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
if (successful === undefined) {
successful = true;
}
if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
(t == 'checkbox' || t == 'radio') && !el.checked ||
(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
tag == 'select' && el.selectedIndex == -1)) {
return null;
}
if (tag == 'select') {
var index = el.selectedIndex;
if (index < 0) {
return null;
}
var a = [], ops = el.options;
var one = (t == 'select-one');
var max = (one ? index+1 : ops.length);
for(var i=(one ? index : 0); i < max; i++) {
var op = ops[i];
if (op.selected) {
var v = op.value;
if (!v) { // extra pain for IE...
v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
}
if (one) {
return v;
}
a.push(v);
}
}
return a;
}
return $(el).val();
};
/**
* Clears the form data.  Takes the following actions on the form's input fields:
*  - input text fields will have their 'value' property set to the empty string
*  - select elements will have their 'selectedIndex' property set to -1
*  - checkbox and radio inputs will have their 'checked' property set to false
*  - inputs of type submit, button, reset, and hidden will *not* be effected
*  - button elements will *not* be effected
*/
$.fn.clearForm = function(includeHidden) {
return this.each(function() {
$('input,select,textarea', this).clearFields(includeHidden);
});
};
/**
* Clears the selected form elements.
*/
$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
return this.each(function() {
var t = this.type, tag = this.tagName.toLowerCase();
if (re.test(t) || tag == 'textarea' || (includeHidden && /hidden/.test(t)) ) {
this.value = '';
}
else if (t == 'checkbox' || t == 'radio') {
this.checked = false;
}
else if (tag == 'select') {
this.selectedIndex = -1;
}
});
};
/**
* Resets the form data.  Causes all form elements to be reset to their original value.
*/
$.fn.resetForm = function() {
return this.each(function() {
// guard against an input with the name of 'reset'
// note that IE reports the reset function as an 'object'
if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
this.reset();
}
});
};
/**
* Enables or disables any matching elements.
*/
$.fn.enable = function(b) {
if (b === undefined) {
b = true;
}
return this.each(function() {
this.disabled = !b;
});
};
/**
* Checks/unchecks any matching checkboxes or radio buttons and
* selects/deselects and matching option elements.
*/
$.fn.selected = function(select) {
if (select === undefined) {
select = true;
}
return this.each(function() {
var t = this.type;
if (t == 'checkbox' || t == 'radio') {
this.checked = select;
}
else if (this.tagName.toLowerCase() == 'option') {
var $sel = $(this).parent('select');
if (select && $sel[0] && $sel[0].type == 'select-one') {
// deselect all other options
$sel.find('option').selected(false);
}
this.selected = select;
}
});
};
// expose debug var
$.fn.ajaxSubmit.debug = false;
// helper fn for console logging
function log() {
if (!$.fn.ajaxSubmit.debug) 
return;
var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
if (window.console && window.console.log) {
window.console.log(msg);
}
else if (window.opera && window.opera.postError) {
window.opera.postError(msg);
}
};
})(jQuery);
/*
* jqModal - Minimalist Modaling with jQuery
*   (http://dev.iceburg.net/jquery/jqModal/)
*
* Copyright (c) 2007,2008 Brice Burgess <bhb@iceburg.net>
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
* 
* $Version: 07/06/2008 +r13
*/
(function($) {
$.fn.jqm=function(o){
var p={
overlay: 50,
overlayClass: 'jqmOverlay',
closeClass: 'jqmClose',
trigger: '.jqModal',
ajax: F,
ajaxText: '',
target: F,
modal: F,
toTop: F,
onShow: F,
onHide: F,
onLoad: F
};
return this.each(function(){if(this._jqm)return H[this._jqm].c=$.extend({},H[this._jqm].c,o);s++;this._jqm=s;
H[s]={c:$.extend(p,$.jqm.params,o),a:F,w:$(this).addClass('jqmID'+s),s:s};
if(p.trigger)$(this).jqmAddTrigger(p.trigger);
});};
$.fn.jqmAddClose=function(e){return hs(this,e,'jqmHide');};
$.fn.jqmAddTrigger=function(e){return hs(this,e,'jqmShow');};
$.fn.jqmShow=function(t){return this.each(function(){$.jqm.open(this._jqm,t);});};
$.fn.jqmHide=function(t){return this.each(function(){$.jqm.close(this._jqm,t)});};
$.jqm = {
hash:{},
open:function(s,t){var h=H[s],c=h.c,cc='.'+c.closeClass,z=(parseInt(h.w.css('z-index'))),z=(z>0)?z:3000,o=$('<div></div>').css({height:'100%',width:'100%',position:'fixed',left:0,top:0,'z-index':z-1,opacity:c.overlay/100});if(h.a)return F;h.t=t;h.a=true;h.w.css('z-index',z);
if(c.modal) {if(!A[0])L('bind');A.push(s);}
else if(c.overlay > 0)h.w.jqmAddClose(o);
else o=F;
h.o=(o)?o.addClass(c.overlayClass).prependTo('body'):F;
if(ie6){$('html,body').css({height:'100%',width:'100%'});if(o){o=o.css({position:'absolute'})[0];for(var y in {Top:1,Left:1})o.style.setExpression(y.toLowerCase(),"(_=(document.documentElement.scroll"+y+" || document.body.scroll"+y+"))+'px'");}}
if(c.ajax) {var r=c.target||h.w,u=c.ajax,r=(typeof r == 'string')?$(r,h.w):$(r),u=(u.substr(0,1) == '@')?$(t).attr(u.substring(1)):u;
r.html(c.ajaxText).load(u,function(){if(c.onLoad)c.onLoad.call(this,h);if(cc)h.w.jqmAddClose($(cc,h.w));e(h);});}
else if(cc)h.w.jqmAddClose($(cc,h.w));
if(c.toTop&&h.o)h.w.before('<span id="jqmP'+h.w[0]._jqm+'"></span>').insertAfter(h.o);
(c.onShow)?c.onShow(h):h.w.show();e(h);return F;
},
close:function(s){var h=H[s];if(!h.a)return F;h.a=F;
if(A[0]){A.pop();if(!A[0])L('unbind');}
if(h.c.toTop&&h.o)$('#jqmP'+h.w[0]._jqm).after(h.w).remove();
if(h.c.onHide)h.c.onHide(h);else{h.w.hide();if(h.o)h.o.remove();} return F;
},
params:{}};
var s=0,H=$.jqm.hash,A=[],ie6=$.browser.msie&&($.browser.version == "6.0"),F=false,
i=$('<iframe src="javascript:false;document.write(\'\');" class="jqm"></iframe>').css({opacity:0}),
e=function(h){if(ie6)if(h.o)h.o.html('<p style="width:100%;height:100%"/>').prepend(i);else if(!$('iframe.jqm',h.w)[0])h.w.prepend(i); f(h);},
f=function(h){try{$(':input:visible',h.w)[0].focus();}catch(_){}},
L=function(t){$()[t]("keypress",m)[t]("keydown",m)[t]("mousedown",m);},
m=function(e){var h=H[A[A.length-1]],r=(!$(e.target).parents('.jqmID'+h.s)[0]);if(r)f(h);return !r;},
hs=function(w,t,c){return w.each(function(){var s=this._jqm;$(t).each(function() {
if(!this[c]){this[c]=[];$(this).click(function(){for(var i in {jqmShow:1,jqmHide:1})for(var s in this[i])if(H[this[i][s]])H[this[i][s]].w[i](this);return F;});}this[c].push(s);});});};
})(jQuery);
// CREDIT GOES TO: http://blog.stchur.com/2007/04/06/serializing-objects-in-javascript/
jQuery.serialize = function(_obj)
{
// Let Gecko browsers do this the easy way
if (typeof _obj.toSource !== 'undefined' && typeof _obj.callee === 'undefined')
{
return _obj.toSource();
}
// Other browsers must do it the hard way
switch (typeof _obj)
{
// numbers, booleans, and functions are trivial:
// just return the object itself since its default .toString()
// gives us exactly what we want
case 'number':
case 'boolean':
case 'function':
return _obj;
break;
// for JSON format, strings need to be wrapped in quotes
case 'string':
return '"' + _obj + '"';
break;
case 'object':
var str;
if (_obj.constructor === Array || typeof _obj.callee !== 'undefined')
{
str = '[';
var i, len = _obj.length;
for (i = 0; i < len-1; i++) { str += jQuery.serialize(_obj[i]) + ','; }
str += serialize(_obj[i]) + ']';
}
else
{
str = '{';
var key;
for (key in _obj) { str += '"' + key + '":' + jQuery.serialize(_obj[key]) + ','; }
str = str.replace(/\,$/, '') + '}';
}
return str;
break;
default:
return 'UNKNOWN';
break;
}
}
/**
* Cookie plugin
*
* Copyright (c) 2006 Klaus Hartl (stilbuero.de)
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
*/
/**
* Create a cookie with the given name and value and other optional parameters.
*
* @example $.cookie('the_cookie', 'the_value');
* @desc Set the value of a cookie.
* @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
* @desc Create a cookie with all available options.
* @example $.cookie('the_cookie', 'the_value');
* @desc Create a session cookie.
* @example $.cookie('the_cookie', null);
* @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
*       used when the cookie was set.
*
* @param String name The name of the cookie.
* @param String value The value of the cookie.
* @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
* @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
*                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
*                             If set to null or omitted, the cookie will be a session cookie and will not be retained
*                             when the the browser exits.
* @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
* @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
* @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
*                        require a secure protocol (like HTTPS).
* @type undefined
*
* @name $.cookie
* @cat Plugins/Cookie
* @author Klaus Hartl/klaus.hartl@stilbuero.de
*/
/**
* Get the value of a cookie with the given name.
*
* @example $.cookie('the_cookie');
* @desc Get the value of a cookie.
*
* @param String name The name of the cookie.
* @return The value of the cookie.
* @type String
*
* @name $.cookie
* @cat Plugins/Cookie
* @author Klaus Hartl/klaus.hartl@stilbuero.de
*/
jQuery.cookie = function(name, value, options) {
if (typeof value != 'undefined') { // name and value given, set cookie
options = options || {};
if (value === null) {
value = '';
options.expires = -1;
}
var expires = '';
if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
var date;
if (typeof options.expires == 'number') {
date = new Date();
date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
} else {
date = options.expires;
}
expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
}
// CAUTION: Needed to parenthesize options.path and options.domain
// in the following expressions, otherwise they evaluate to undefined
// in the packed version for some reason...
var path = options.path ? '; path=' + (options.path) : '';
var domain = options.domain ? '; domain=' + (options.domain) : '';
var secure = options.secure ? '; secure' : '';
document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
} else { // only name given, get cookie
var cookieValue = null;
if (document.cookie && document.cookie != '') {
var cookies = document.cookie.split(';');
for (var i = 0; i < cookies.length; i++) {
var cookie = jQuery.trim(cookies[i]);
// Does this cookie string begin with the name we want?
if (cookie.substring(0, name.length + 1) == (name + '=')) {
cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
break;
}
}
}
return cookieValue;
}
};
// requires the jquery.cookie.js, and the jquery.serialize.js
jQuery.supercookie = function(name, key, value, options) {
if (typeof value != 'undefined') { // name and value given, set cookie
var cookieObj = jQuery.supercookie(name);
cookieObj[key] = value;
var cookieVal = escape(jQuery.serialize(cookieObj));
jQuery.cookie(name, cookieVal, options);
} else { // only name given, get cookie
var cookie = jQuery.cookie(name);
var cookieObj = null;
if (cookie) {
eval('cookieObj = ' + unescape(cookie));
}
if (!cookieObj) cookieObj = {};
if (key){
if (cookieObj[key]){
return cookieObj[key];
} else {
return null;
}
} else {
return cookieObj;
}
}
};
/*!
* jQuery resize event - v1.1 - 3/14/2010
* http://benalman.com/projects/jquery-resize-plugin/
* 
* Copyright (c) 2010 "Cowboy" Ben Alman
* Dual licensed under the MIT and GPL licenses.
* http://benalman.com/about/license/
*/
// Script: jQuery resize event
//
// *Version: 1.1, Last updated: 3/14/2010*
// 
// Project Home - http://benalman.com/projects/jquery-resize-plugin/
// GitHub       - http://github.com/cowboy/jquery-resize/
// Source       - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.js
// (Minified)   - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.min.js (1.0kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrates a few
// ways in which this plugin can be used.
// 
// resize event - http://benalman.com/code/projects/jquery-resize/examples/resize/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-resize/unit/
// 
// About: Release History
// 
// 1.1 - (3/14/2010) Fixed a minor bug that was causing the event to trigger
//       immediately after bind in some circumstances. Also changed $.fn.data
//       to $.data to improve performance.
// 1.0 - (2/10/2010) Initial release
(function($,window,undefined){
'$:nomunge'; // Used by YUI compressor.
// A jQuery object containing all non-window elements to which the resize
// event is bound.
var elems = $([]),
// Extend $.resize if it already exists, otherwise create it.
jq_resize = $.resize = $.extend( $.resize, {} ),
timeout_id,
// Reused strings.
str_setTimeout = 'setTimeout',
str_resize = 'resize',
str_data = str_resize + '-special-event',
str_delay = 'delay',
str_throttle = 'throttleWindow';
// Property: jQuery.resize.delay
// 
// The numeric interval (in milliseconds) at which the resize event polling
// loop executes. Defaults to 250.
jq_resize[ str_delay ] = 250;
// Property: jQuery.resize.throttleWindow
// 
// Throttle the native window object resize event to fire no more than once
// every <jQuery.resize.delay> milliseconds. Defaults to true.
// 
// Because the window object has its own resize event, it doesn't need to be
// provided by this plugin, and its execution can be left entirely up to the
// browser. However, since certain browsers fire the resize event continuously
// while others do not, enabling this will throttle the window resize event,
// making event behavior consistent across all elements in all browsers.
// 
// While setting this property to false will disable window object resize
// event throttling, please note that this property must be changed before any
// window object resize event callbacks are bound.
jq_resize[ str_throttle ] = true;
// Event: resize event
// 
// Fired when an element's width or height changes. Because browsers only
// provide this event for the window element, for other elements a polling
// loop is initialized, running every <jQuery.resize.delay> milliseconds
// to see if elements' dimensions have changed. You may bind with either
// .resize( fn ) or .bind( "resize", fn ), and unbind with .unbind( "resize" ).
// 
// Usage:
// 
// > jQuery('selector').bind( 'resize', function(e) {
// >   // element's width or height has changed!
// >   ...
// > });
// 
// Additional Notes:
// 
// * The polling loop is not created until at least one callback is actually
//   bound to the 'resize' event, and this single polling loop is shared
//   across all elements.
// 
// Double firing issue in jQuery 1.3.2:
// 
// While this plugin works in jQuery 1.3.2, if an element's event callbacks
// are manually triggered via .trigger( 'resize' ) or .resize() those
// callbacks may double-fire, due to limitations in the jQuery 1.3.2 special
// events system. This is not an issue when using jQuery 1.4+.
// 
// > // While this works in jQuery 1.4+
// > $(elem).css({ width: new_w, height: new_h }).resize();
// > 
// > // In jQuery 1.3.2, you need to do this:
// > var elem = $(elem);
// > elem.css({ width: new_w, height: new_h });
// > elem.data( 'resize-special-event', { width: elem.width(), height: elem.height() } );
// > elem.resize();
$.event.special[ str_resize ] = {
// Called only when the first 'resize' event callback is bound per element.
setup: function() {
// Since window has its own native 'resize' event, return false so that
// jQuery will bind the event using DOM methods. Since only 'window'
// objects have a .setTimeout method, this should be a sufficient test.
// Unless, of course, we're throttling the 'resize' event for window.
if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
var elem = $(this);
// Add this element to the list of internal elements to monitor.
elems = elems.add( elem );
// Initialize data store on the element.
$.data( this, str_data, { w: elem.width(), h: elem.height() } );
// If this is the first element added, start the polling loop.
if ( elems.length === 1 ) {
loopy();
}
},
// Called only when the last 'resize' event callback is unbound per element.
teardown: function() {
// Since window has its own native 'resize' event, return false so that
// jQuery will unbind the event using DOM methods. Since only 'window'
// objects have a .setTimeout method, this should be a sufficient test.
// Unless, of course, we're throttling the 'resize' event for window.
if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
var elem = $(this);
// Remove this element from the list of internal elements to monitor.
elems = elems.not( elem );
// Remove any data stored on the element.
elem.removeData( str_data );
// If this is the last element removed, stop the polling loop.
if ( !elems.length ) {
clearTimeout( timeout_id );
}
},
// Called every time a 'resize' event callback is bound per element (new in
// jQuery 1.4).
add: function( handleObj ) {
// Since window has its own native 'resize' event, return false so that
// jQuery doesn't modify the event object. Unless, of course, we're
// throttling the 'resize' event for window.
if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
var old_handler;
// The new_handler function is executed every time the event is triggered.
// This is used to update the internal element data store with the width
// and height when the event is triggered manually, to avoid double-firing
// of the event callback. See the "Double firing issue in jQuery 1.3.2"
// comments above for more information.
function new_handler( e, w, h ) {
var elem = $(this),
data = $.data( this, str_data );
// If called from the polling loop, w and h will be passed in as
// arguments. If called manually, via .trigger( 'resize' ) or .resize(),
// those values will need to be computed.
// MODIFIED BY David McReynolds Daylight Studio 2013-09-04 - added check that data exists so it won't throw an error
if (data){
data.w = w !== undefined ? w : elem.width();
data.h = h !== undefined ? h : elem.height();
old_handler.apply( this, arguments );
}
};
// This may seem a little complicated, but it normalizes the special event
// .add method between jQuery 1.4/1.4.1 and 1.4.2+
if ( $.isFunction( handleObj ) ) {
// 1.4, 1.4.1
old_handler = handleObj;
return new_handler;
} else {
// 1.4.2+
old_handler = handleObj.handler;
handleObj.handler = new_handler;
}
}
};
function loopy() {
// Start the polling loop, asynchronously.
timeout_id = window[ str_setTimeout ](function(){
// Iterate over all elements to which the 'resize' event is bound.
elems.each(function(){
var elem = $(this),
width = elem.width(),
height = elem.height(),
data = $.data( this, str_data );
// If element size has changed since the last time, update the element
// data store and trigger the 'resize' event.
// MODIFIED BY David McReynolds Daylight Studio 2014-05-22 - added check that data exists so it won't throw an error
if (data && (width !== data.w || height !== data.h )) {
elem.trigger( str_resize, [ data.w = width, data.h = height ] );
}
});
// Loop.
loopy();
}, jq_resize[ str_delay ] );
};
})(jQuery,this);
function initFuelNamespace(){
var f;
if (window.fuel == undefined){
if (top.window.fuel != undefined){
f = top.window.fuel;
} else {
f = {};
}
} else {
f = window.fuel;
}
return f;
}
//fuel = initFuelNamespace();
//console.log(fuel)
if (typeof(window.fuel) == 'undefined'){
window.fuel = {};
}
fuel.lang = function(key){
return __FUEL_LOCALIZED__[key];
}
// used to get id values in case the form fields are namespaced
fuel.getFieldId = function(field, context){
if (window.__FUEL_INLINE_EDITING != undefined){
var val = $('.__fuel_module__', context).attr('id');
var prefix = val.split('--')[0];
return prefix + '--' + field;
} else {
return field;
}
}
fuel.getModule = function(context){
// inline editing
if (window.__FUEL_INLINE_EDITING != undefined){
return $('.__fuel_module__', context).val();
} else {
// jqx controller instance name is "page"
return page.module;
}
}
fuel.modalWindow = function(html, cssClass, autoResize, onLoadCallback, onCloseCallback){
var modalId = '__FUEL_modal__';
if (!cssClass) cssClass = '';
var $context = $('body', window.document);
if (!$('#' + modalId, $context).length){
var modalHTML = '<div id="' + modalId + '"><div class="loader"></div><a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div></div>';
} else {
$('#' + modalId, $context).html('<div class="loader"></div><a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div>');
}
$context.append(modalHTML);
$modal = $('#' + modalId, $context);
$modal.attr('class', '__fuel__ __fuel_modal__ jqmWindow ' + cssClass)
// Hack to prevent the iframe from refreshing on close
$(document).off('mousedown', '.modal_close');
$(document).on('mousedown', '.modal_close', function(e){
e.preventDefault();
$('.modal_content').empty();
$modal.jqmHide();
})
var modalOnHide = function(){
$('#' + modalId, $context).hide();
$('.jqmOverlay', $context).remove();
if (onCloseCallback) onCloseCallback();
}
var modalWidth = $modal.outerWidth();
var centerWidth = -((modalWidth/2));
$modal.css('marginLeft', centerWidth + 'px');
// show it first so we don't get the cancellation error in the console
// set jqm window options
var jqmOpts = { onHide: modalOnHide, toTop:true };
if (onLoadCallback){
jqmOpts.onLoad = onLoadCallback;
}
$modal.jqm(jqmOpts).jqmShow();
$modal.find('.modal_content').empty().append(html);
$modal.find('iframe').on('load', function(){
$('.jqmWindow .loader', $context).hide();
var iframe = this;
var contentDoc = iframe.contentDocument;
$('.cancel', contentDoc).add('.modal_close').click(function(e){
e.preventDefault();
$modal.jqmHide();
})
if (autoResize){
setTimeout(function(){
docHeight = fuel.calcHeight(contentDoc);
if (iframe.contentWindow){
$(iframe.contentWindow.parent.document).find('#' + modalId + 'iframe').height(docHeight);
fuel.cascadeIframeWindowSize(docHeight);
$(iframe).height(docHeight);
}
}, 250);
}
})
return $modal;
}
fuel.closeModal = function(){
var modalId = '__FUEL_modal__';
$modal = $('#' + modalId, document.top);
if ($modal.find('.modal_close').length){
$modal.find('.modal_close').trigger('mousedown');
} else {
$('#' + modalId).jqmHide();
}
}
fuel.getModule = function(context){
if (window.fuel && window.fuel.module){
return window.fuel.module;
}
if (context == undefined) context = null;
var module = ($('.__fuel_module__', context).length) ? $('.__fuel_module__', context).val() : null;
return module;
}
fuel.getModuleURI = function(context){
if (context == undefined) context = null;
var module = ($('.__fuel_module_uri__').length) ? $('.__fuel_module_uri__').val() : null;
return module;
}
fuel.isTop = function(){
return self == top;
}
fuel.windowLevel = function(){
var level = 0;
var win = window;
while (win != top && win.parent != null){ 
level++; 
win = win.parent;
}
return level;
}
fuel.calcHeight = function(context){
var height = 0;
if ($('#login', context).length){
var elems = '#login'; 
} else {
var elems = '#fuel_main_top_panel, #fuel_actions, #fuel_notification, #fuel_main_content_inner, #list_container, .instructions, .modal_height';
}
$(elems, context).each(function(i){
// must use false to get around bug with jQuery 1.8
var outerHeight = parseInt($(this).outerHeight(false));
if (outerHeight) height += outerHeight;
})
if (height > 600) {
height = 600;
} else {
height += 30;
}
return height;
}
fuel.adjustIframeWindowSize = function(){
var iframe = $('.inline_iframe', top.window.document);
if (iframe.length){
iframe = iframe[0];
var contentDoc = iframe.contentDocument;
var height = parseInt(fuel.calcHeight(contentDoc));
var width = parseInt($('#fuel_main_content_inner .form', contentDoc).width()) + 50;
$(iframe).height(height);
$(iframe).width(width);
}
}
fuel.cascadeIframeWindowSize = function(height){
var level = 0;
if (height) height = height + 100;
//var win = window;
// console.log(win.document.title)
$('.inline_iframe', top.window.document).height(height);
// do 
// {
// level++;
// //height = fuel.calcHeight(win.document);
// console.log($('.inline_iframe', win.document))
// $('.inline_iframe', win.document).height(height);
// win = win.parent;
// console.log(win.document.title)
// 
// } while (win != top && win.parent != null)
//return level;
}
// exposed fuel methods
if (fuel == undefined) var fuel = {};
(function($) {
var initObj = __FUEL_INIT_PARAMS__;
var pageId = initObj.pageId;
var pageLocation = initObj.pageLocation;
var basePath = initObj.basePath;
var cookiePath = initObj.cookiePath;
var imgPath = initObj.imgPath;
var cssPath = initObj.cssPath;
var jsPath = initObj.jsPath;
var assetsImgPath = initObj.assetsImgPath;
var assetsPath = initObj.assetsPath;
var assetsAccept = initObj.assetsAccept;
var editor = initObj.editor;
var editorConfig = initObj.editorConfig;
var markers = null;
var X_OFFSET = 16;
var Y_OFFSET = 16;
var editorsOn = (parseInt($.supercookie('fuel_bar', 'show_editable_areas')) == 1);
var fuelBarOn = (parseInt($.supercookie('fuel_bar', 'show_fuel_bar')) == 1);
var activeEditor;
var activeField;
var assetFolder;
var iconHeight = 16;
var maxAdjustLoops = (fuel.maxAdjustLoops) ? fuel.maxAdjustLoops : 10;
// limit it to the most common for performance
var useAutoAdjust = (fuel.useAutoAdjust === false) ? false : true;
var resizeTags = (fuel.resizeTags) ? fuel.resizeTags : 'section,div,p,li';
jQuery.resize.delay = (fuel.resizeDelay) ? fuel.resizeDelay : 1000;
function lang(key){
return __FUEL_LOCALIZED__[key];
}
$(document).ready(function(){
$('body').addClass('__fuel_inline__');
function init(){
// disable the toolbar if it is being view from within the admin
if (window.top != window){
$('#__fuel_edit_bar__').hide();
return;
}
initMarkers();
initFUELBar();
// bind exposed global methods
fuel.refresh = function(){
refresh();
}
fuel.modalWindow = function (html, cssClass, callback){
var modalId = '__FUEL_modal__';
if (!cssClass) cssClass = '';
var $context = $('body', top.window.document);
var modalHtml = '<a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div>';
if (!$('#' + modalId).length){
var modalHTML = '<div id="' + modalId + '" class="__fuel__ __fuel_modal__ jqmWindow ' + cssClass + '"><a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div></div>';
$context.append(modalHTML);
}
// add loading graphic
$('#' + modalId, $context).append('<div class="loader"></div>');
// add overlay and hide iframe overlay 
//$('.jqmOverlay', $context).hide();
$modal = $('#' + modalId, $context);
$modal.find('.modal_content').empty().append(html);
$modal.find('iframe').on('load', function(e){
$('.jqmWindow .loader', $context).remove();
var iframe = this;
var contentDoc = iframe.contentDocument;
var actionsHeight = $('#fuel_actions', contentDoc).length ? $('#fuel_actions', contentDoc).outerHeight(false) : 0;
var notificationsHeight = $('#fuel_notification', contentDoc).length ? $('#fuel_notification', contentDoc).outerHeight(false) : 0;
var mainContentHeight =  $('#fuel_main_content_inner', contentDoc).length ? $('#fuel_main_content_inner', contentDoc).outerHeight(false) : 0;
var listTableHeight = $('#data_table_container', contentDoc).length ? $('#data_table_container', contentDoc).outerHeight(false) : 0;
docHeight = actionsHeight + notificationsHeight + mainContentHeight + listTableHeight + 30; // 30 is a fudge factor
//docHeight = 100
// var heightFudge = $('#fuel_notification', contentDoc).outerHeight() + 30; // padding for #fuel_main_content_inner is 15 top and 15 bottom
// heightFudge += $('#fuel_actions', contentDoc).outerHeight();
// var docHeight = $('#fuel_main_content_inner', contentDoc).outerHeight() + heightFudge; // bottom margin is added... not sure from what though
//console.log(docHeight)
if (docHeight > 450) docHeight = 450;
var docWidth = 850; // 74 includes the 37 in padding on each side
$(iframe).height(docHeight);
$(iframe).width(docWidth);
})
$modal.jqm({}).jqmShow();
}
fuel.refreshIframeSize = function(iframe){
var i = 0;
// polling
var interval = setInterval(function(){
fuel.setIframeSize(iframe);
if (i > 20) clearInterval(interval);
i++;
}, 100);
}
fuel.setIframeSize = function(iframe){
var MIN_WIDTH = 850;
var contentDoc = iframe.contentDocument;
var docHeight = fuel.calcHeight(contentDoc);
if ($('#fuel_main_content_inner .form, #fuel_actions', contentDoc).length){
var width1 = $('#fuel_main_content_inner .form', contentDoc).outerWidth(false) + 74; // 74 includes the 37 in padding on each side
var width2 = $('#fuel_actions', contentDoc).outerWidth(false);
var docWidth = (width1 > width2) ? width1 : width2;
// check if fuel_actions is there so that we don't make it too wide for single variables being edited
if (docWidth < MIN_WIDTH && $('#fuel_actions', contentDoc).length) docWidth = MIN_WIDTH;
} else if ($('#login', contentDoc).length){
docWidth = $('#login', contentDoc).width();
} else {
docWidth = $(contentDoc).width();
}
if (docHeight == 0){
docHeight = $(contentDoc).height();
}
$(iframe).height(docHeight);
$(iframe).width(docWidth);
}
}
function initMarkers(){
$('.__fuel_edit__').remove();
var markers = $(".__fuel_marker__");
var toggleEditOff = true;
if (markers.length > 0){
$body = $('body');
markers.each(function(i){
var $this = $(this);
var module = $this.attr('data-module');
if ((module == 'pagevariables' && pageId != 0) || module != 'pagevariables'){
$this.attr('id', '__fuel_marker__' + i);
var coords = getMarkerPosition($this);
var varName = $this.attr('title');
var newClass = ($this.attr('data-rel').substr(0, 6) == 'create') ? ' __fuel_edit_marker_new__' : '';
var publishedClass = ($this.attr('data-published') == '0') ? ' __fuel_edit_marker_unpublished__' : '';
var html = '<div id="__fuel_edit__' + i + '" style="left:' + coords.x + 'px; top:' + coords.y + 'px;" class="__fuel__ __fuel_edit__" title="' + varName + '" data-module="' + module + '">';
var dataHref = $this.attr('data-href').replace(/\|/, '/');
html += '<a href="' + dataHref + '" rel="' + $this.attr('data-rel') + '" class="__fuel_edit_marker__'+ newClass + publishedClass + '">';
html += '<span class="__fuel_edit_marker_inner__">' + varName + '</span>';
html += '</a>';
html += '<div class="__fuel_edit_form__" style="display: none;"><img src="' + imgPath + 'spinner_sm.gif" width="16" height="16" alt="loading"></div>';
html += '</div>';
$body.append(html);
toggleEditOff = false;
}
});
$('.__fuel_edit_marker_inner__').hide();
initEditors();
}
if (toggleEditOff) $('#__fuel_page_edit_toggle__').parent().hide();
}
function refresh(){
if (editorsOn){
moveMarkers();
if (activeEditor){
var iframe = activeEditor.find('iframe')[0];
//fuel.setIframeSize(iframe);
}
}
}
function moveMarkers(){
var markers = $(".__fuel_marker__");
markers.each(function(i){
var $this = $(this);
var coords = getMarkerPosition($this);
$('#__fuel_edit__' + i).css({left: coords.x, top: coords.y});
// determine if it is visible so that we can filter out the hidden to speed things up
if ($this.filter(':hidden').length != 0) {
$('#__fuel_edit__' + i).hide();
} else {
$('#__fuel_edit__' + i).show();
}
});
// re-adjust markers so they don't overlap
var editors = $(".__fuel_edit__:visible");
editors.each(function(i){
adjustPosition(editors, $(this), 0);
});
}
function getMarkerPosition(marker){
var offset = marker.offset();
var xCoord = offset.left;
var yCoord = offset.top + iconHeight; // 16 is the icon height
var x = (xCoord <= X_OFFSET) ? 0 : xCoord - X_OFFSET;
var y = (yCoord <= Y_OFFSET) ? 0 : yCoord - Y_OFFSET;
return {x:x, y:y};
}
// used to prevent overlaps of editors
function adjustPosition(editors, $obj, counter){
editors.each(function(i){
var $compareObj = $(this);
var topPos = parseInt($obj.css('top'));
var leftPos = parseInt($obj.css('left'));
var objAttrsId = $obj.attr('id');
var objCompareAttrsId = $compareObj.attr('id');
if (counter <= maxAdjustLoops && $obj.attr('id') != $compareObj.attr('id') && 
Math.abs(topPos - parseInt($compareObj.css('top'))) < Y_OFFSET && 
Math.abs(leftPos - parseInt($compareObj.css('left'))) < X_OFFSET){
$compareObj.css('top', (topPos + Y_OFFSET) + 'px');
counter++;
adjustPosition(editors, $obj, counter);
return false;
}
});
}
function initEditors(){
var formAction = '';
var editors = $('.__fuel_edit__');
var resetCss = {height: 'auto', width: 'auto', opacity: 1, display: 'block'};
var closeEditor = function(){
// turn off inline editing mode
if (activeEditor){
var iframe = activeEditor.find('iframe')[0];
var contentDoc = iframe.contentDocument;
// if there was a successful save, then we need to refresh the page
if ($('.success', contentDoc).length){
top.window.location.reload();
} else {
activeEditor.removeClass('__fuel_edit_active__');
activeEditor.find('.__fuel_edit_marker_inner__, .__fuel_edit_form__').stop().css(resetCss).hide();
activeEditor = null;
}
}
}
var ajaxSubmit = function($form){
$form.attr('action', formAction).ajaxSubmit(function(html){
if ($(html).is('error')){
var msg = $(html).html();
if (msg != '' || msg != '1'){
$form.find('.inline_errors').html(msg).animate( { backgroundColor: '#ee6060'}, 1500);
$.scrollTo($form);
}
} else {
closeEditor();
window.location.reload(true);
}
return false;
});
}
// set up cancel button
$('.__fuel_edit__ .ico_cancel').on('click', function(){
closeEditor();
return false;
});
// set up save
$('.__fuel_edit__ .ico_save').on('click', function(){
$form = $(this).parents('.__fuel_edit_form__').find('form');
ajaxSubmit($form);
return false;
});
$('.__fuel_edit__ .delete').on('click', function(){
if (confirm(lang('confirm_delete'))){
$form = $(this).parents('.__fuel_edit_form__').find('form');
$form.find('.__fuel_inline_action__').val('delete');
ajaxSubmit($form);
}
return false;
});
editors.each(function(i){
var $this = $(this);
var module = $this.attr('data-module');
var _anchor = $('.__fuel_edit_marker__', this);
_anchor.mouseover(function(){
$('.__fuel_edit_marker_inner__', this).stop().css(resetCss).show();
});
_anchor.mouseout(function(){
if ((activeEditor && activeEditor.attr('title') == $this.attr('title'))){
return;
} else {
$('.__fuel_edit_marker_inner__', this).stop().css(resetCss).hide();
}
});
_anchor.click(function(e){
if (!activeEditor || activeEditor != $this){
if ($('.__fuel_edit_form__', $this).children().not('img').length == 0){
var relArr = $(this).attr('rel').split('|');
var param1 = relArr[0];
if (module == 'pagevariables'){
var param2 = pageId;
} else {
var param2 = (relArr.length >= 2) ? relArr[1] : '';
}
if (param1.substr(0, 6) == 'create'){
var qString = (param2.length) ? '?' + param2 : '';
var url = $(this).attr('href') + qString;
} else {
var url = $(this).attr('href') + param1 + '/' + param2;
}
var lang = $('#__fuel_language__').val();
if (lang && lang.length){
url = url + '?lang=' + $('#__fuel_language__').val();
}
if (_anchor.next('.__fuel_edit_form__').find('iframe').length == 0){
var iframeId = '__fuel_iframe__' + $this.attr('id');
_anchor.next('.__fuel_edit_form__').html('<div class="loader"></div><iframe src="' + url +'" id="' + iframeId +'" frameborder="0" scrolling="no" class="inline_iframe"></iframe>');
$('#' + iframeId).on('load', function(){
var iframe = this;
var contentDoc = iframe.contentDocument;
// we check for the variable "saved" on the child windo
// if set to true, then we refresh the entire window so the changes can be seen
if (iframe.contentWindow.saved){
closeEditor();
window.location.reload();
} else {
$('.cancel', contentDoc).click(function(e){
closeEditor();
return false;
});
$('#' + iframeId).prev().hide();
fuel.refreshIframeSize(iframe);
}
})
} else {
// set the frame size just in case it wasn't set
var iframe = _anchor.next('.__fuel_edit_form__').find('iframe');
fuel.setIframeSize(iframe);
}
_anchor.next('.__fuel_edit_form__').show();
} else { 
_anchor.next('.__fuel_edit_form__').show();
}
$('.__fuel_edit_marker_inner__', this).css(resetCss);
$(this).find('.__fuel_edit_marker_inner__, .__fuel_edit_form__').show();
$this.addClass('__fuel_edit_active__');
if (activeEditor && (activeEditor.attr('title') != $this.attr('title'))) {
closeEditor();
}
activeEditor = $this;
} else {
closeEditor();
}
return false;
});
});
}
function initFUELBar(){
var hideEditors = function(){
if (useAutoAdjust) $(resizeTags).unbind('resize', refresh);
var elem = $('#__fuel_page_edit_toggle__');
$('.__fuel_edit__').hide();
editorsOn = false;
//elem.text('Show Editable Areas');
elem.parent('li').removeClass('active');
$.supercookie('fuel_bar', 'show_editable_areas', '0', {path: cookiePath});
}
var showEditors = function(){
// use the great resize plugin to accomplish this... 
if (useAutoAdjust) $(resizeTags).bind('resize', refresh);
refresh(); // just in case things have moved since they were last turned off
var elem = $('#__fuel_page_edit_toggle__');
$('.__fuel_edit__').show();
editorsOn = true;
//elem.text('Hide Editable Areas');
elem.parent('li').addClass('active');
$.supercookie('fuel_bar', 'show_editable_areas', '1', {path: cookiePath});
}
var toggleEditors = function(shown){
if (shown){
hideEditors();
} else {
showEditors();
}
}
$('#__fuel_page_edit_toggle__').click(
function(){
toggleEditors(editorsOn);
return false;
}
);
$('#__fuel_page_tools__').change(function(){
var url = $(this).val();
if (url == '') return;
var html = '<iframe src="' + url +'?id=' + pageId + '&amp;location=' + pageLocation + '" id="tool_output_iframe" frameborder="0" scrolling="no" style="border: none; height: 0px; width: 0px;"></iframe>';
fuel.modalWindow(html);
$(this).val(''); // reset it back to top
return false;
});
$('#__fuel_page_layout__').change(function(){
$('#__fuel_edit_bar_form__').ajaxSubmit(function(){
window.location.reload();
});
return false;
});
$('#__fuel_language__').change(function(){
var param = $(this).attr('name');
var lang = $(this).val();
if ($('#__fuel_language_mode__').val() == 'segment'){
if ($('#__fuel_language_default__').val() != lang){
var url = basePath + lang + '/' + pageLocation;
} else {
var url = basePath + pageLocation;
}
} else {
var beginUrl = window.location.href.split('?')[0];
var queryStr = window.location.search.substring(1);
var regEx = new RegExp('&?' + param + '=[^&]*');
// remove any lang field values so it doesn't duplicate it in the query string
queryStr = queryStr.replace(regEx, '');
queryStr += '&' + param + '=' + lang;
var url = beginUrl + '?' + queryStr;
}
window.location = url;
return false;
});
$('#__fuel_page_publish_toggle__').click(function(e){
var $this = this;
var elem = $('#__fuel_page_published__')
var val = (elem.val() == 'yes') ? 'no' : 'yes';
elem.val(val);
$('#__fuel_edit_bar_form__').ajaxSubmit(function(){
window.location.reload();
});
return false;
});
$('#__fuel_page_cache_toggle__').click(function(e){
var elem = $('#__fuel_page_cached__')
var val = (elem.val() == 'yes') ? 'no' : 'yes';
elem.val(val);
$('#__fuel_edit_bar_form__').ajaxSubmit(function(){
window.location.reload();
});
return false;
});
$('#__fuel_page_others__').change(function(){
window.location = basePath + $(this).val();
});
var hideFuelBar = function(animate){
var elem = $('#__fuel_page_toolbar_toggle__');
var exposedWidth = 0;
$('.__fuel__ .exposed').each(function(i){
exposedWidth += $(this).innerWidth();
});
var barHideX = $('#__fuel_edit_bar__').width() - (exposedWidth + 1);
if (animate){
$("#__fuel_edit_bar__").animate({ right: '-' + barHideX + 'px'}, 500);
} else {
$("#__fuel_edit_bar__").css({ right: '-' + barHideX + 'px'});
}
fuelBarOn = false;
elem.parent('li').removeClass('active');
$.supercookie('fuel_bar', 'show_fuel_bar', '0', {path: cookiePath});
}
var showFuelBar = function(animate){
var elem = $('#__fuel_page_toolbar_toggle__');
if (animate){
$("#__fuel_edit_bar__").show().animate({ right: '0px'}, 500);
} else {
$("#__fuel_edit_bar__").show().css({ right: '0px'});
}
$('.__fuel_edit_bar__').width();
fuelBarOn = true;
elem.parent('li').addClass('active');
$.supercookie('fuel_bar', 'show_fuel_bar', '1', {path: cookiePath});
}
$('#__fuel_page_toolbar_toggle__').click(
function(){
toggleFuelBar(fuelBarOn, true);
return false;
}
);
var toggleFuelBar = function(shown, animate){
if (shown){
hideFuelBar(animate);
} else {
showFuelBar(animate);
}
}
// change to negative so it will toggle correctly
$("#__fuel_edit_bar__").show();
toggleFuelBar(!fuelBarOn, false);
toggleEditors(!editorsOn, false);
}
init();
});
})(jQuery);
